{
  "name": "Asset Quality Check",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "quality-check",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "quality-webhook",
      "name": "Quality Check Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "quality-check-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Input Validation for Quality Check\n// Accepts: asset_url OR s3_key\n\nconst input = $input.first().json;\n\nif (!input.asset_url && !input.s3_key) {\n  throw new Error('Either asset_url or s3_key is required');\n}\n\n// Build the asset URL if only s3_key provided\nlet assetUrl = input.asset_url;\nif (!assetUrl && input.s3_key) {\n  const bucket = input.s3_bucket || 'ziggie-assets-prod';\n  assetUrl = `https://${bucket}.s3.eu-north-1.amazonaws.com/${input.s3_key}`;\n}\n\n// Generate check ID\nconst checkId = `qc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\nreturn {\n  json: {\n    checkId: checkId,\n    assetUrl: assetUrl,\n    s3Key: input.s3_key || null,\n    assetType: input.asset_type || 'unknown',\n    expectedDimensions: input.expected_dimensions || null,\n    qualityThreshold: input.quality_threshold || 'AA',\n    checkTransparency: input.check_transparency !== false,\n    checkEdges: input.check_edges !== false,\n    checkArtifacts: input.check_artifacts !== false,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validate-qc-input",
      "name": "Validate QC Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.assetUrl }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 30000
        }
      },
      "id": "download-for-check",
      "name": "Download Asset",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Image Quality Analysis\n// Analyzes: dimensions, file size, format, basic quality metrics\n\nconst inputData = $('Validate QC Input').first().json;\nconst binary = $input.first().binary;\n\nif (!binary || !binary.data) {\n  throw new Error('No image binary data received');\n}\n\n// Extract binary metadata\nconst binaryData = binary.data;\nconst fileSize = binaryData.fileSize || 0;\nconst mimeType = binaryData.mimeType || 'unknown';\nconst fileName = binaryData.fileName || 'unknown';\n\n// Basic quality checks\nconst qualityChecks = {\n  dimensions: {\n    passed: true,\n    message: 'Dimensions check placeholder - requires image processing library',\n    details: {\n      expected: inputData.expectedDimensions,\n      actual: 'Requires PIL/Sharp integration'\n    }\n  },\n  fileSize: {\n    passed: fileSize > 1024 && fileSize < 10 * 1024 * 1024,\n    message: fileSize < 1024 ? 'File too small (< 1KB)' : \n             fileSize > 10 * 1024 * 1024 ? 'File too large (> 10MB)' : 'File size acceptable',\n    details: {\n      size: fileSize,\n      sizeFormatted: `${(fileSize / 1024).toFixed(2)} KB`\n    }\n  },\n  format: {\n    passed: ['image/png', 'image/webp', 'image/jpeg'].includes(mimeType),\n    message: `Format: ${mimeType}`,\n    details: {\n      mimeType: mimeType,\n      fileName: fileName\n    }\n  },\n  transparency: {\n    passed: inputData.checkTransparency ? mimeType === 'image/png' || mimeType === 'image/webp' : true,\n    message: mimeType === 'image/png' || mimeType === 'image/webp' ? \n             'Format supports transparency' : 'JPEG does not support transparency',\n    details: {\n      checked: inputData.checkTransparency,\n      supportsAlpha: mimeType !== 'image/jpeg'\n    }\n  }\n};\n\n// Calculate overall score\nconst passedChecks = Object.values(qualityChecks).filter(c => c.passed).length;\nconst totalChecks = Object.keys(qualityChecks).length;\nconst qualityScore = (passedChecks / totalChecks) * 100;\n\n// Determine quality rating\nlet qualityRating;\nif (qualityScore >= 90) qualityRating = 'AAA';\nelse if (qualityScore >= 75) qualityRating = 'AA';\nelse if (qualityScore >= 50) qualityRating = 'A';\nelse qualityRating = 'Poor';\n\n// Check against threshold\nconst thresholdOrder = ['Poor', 'A', 'AA', 'AAA'];\nconst meetsThreshold = thresholdOrder.indexOf(qualityRating) >= \n                       thresholdOrder.indexOf(inputData.qualityThreshold);\n\nreturn {\n  json: {\n    checkId: inputData.checkId,\n    assetUrl: inputData.assetUrl,\n    assetType: inputData.assetType,\n    qualityChecks: qualityChecks,\n    summary: {\n      passedChecks: passedChecks,\n      totalChecks: totalChecks,\n      qualityScore: qualityScore.toFixed(1),\n      qualityRating: qualityRating,\n      threshold: inputData.qualityThreshold,\n      meetsThreshold: meetsThreshold\n    },\n    fileInfo: {\n      fileName: fileName,\n      fileSize: fileSize,\n      mimeType: mimeType\n    },\n    timestamp: inputData.timestamp\n  }\n};"
      },
      "id": "analyze-quality",
      "name": "Analyze Quality",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "threshold-check",
              "leftValue": "={{ $json.summary.meetsThreshold }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "meets-threshold",
      "name": "Meets Threshold?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build passing quality response\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    checkId: data.checkId,\n    status: 'PASSED',\n    assetUrl: data.assetUrl,\n    assetType: data.assetType,\n    qualityRating: data.summary.qualityRating,\n    qualityScore: parseFloat(data.summary.qualityScore),\n    meetsThreshold: true,\n    threshold: data.summary.threshold,\n    checks: data.qualityChecks,\n    fileInfo: data.fileInfo,\n    recommendation: 'Asset is production-ready',\n    completedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "build-pass-response",
      "name": "Build Pass Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "jsCode": "// Build failing quality response with recommendations\n\nconst data = $input.first().json;\n\n// Generate recommendations based on failed checks\nconst recommendations = [];\n\nif (!data.qualityChecks.fileSize.passed) {\n  recommendations.push('Regenerate with different settings to achieve optimal file size');\n}\n\nif (!data.qualityChecks.format.passed) {\n  recommendations.push('Convert to PNG, WebP, or JPEG format');\n}\n\nif (!data.qualityChecks.transparency.passed) {\n  recommendations.push('Regenerate as PNG for transparency support');\n}\n\nif (!data.qualityChecks.dimensions.passed) {\n  recommendations.push('Regenerate with correct dimensions');\n}\n\nreturn {\n  json: {\n    checkId: data.checkId,\n    status: 'FAILED',\n    assetUrl: data.assetUrl,\n    assetType: data.assetType,\n    qualityRating: data.summary.qualityRating,\n    qualityScore: parseFloat(data.summary.qualityScore),\n    meetsThreshold: false,\n    threshold: data.summary.threshold,\n    checks: data.qualityChecks,\n    failedChecks: Object.entries(data.qualityChecks)\n      .filter(([key, val]) => !val.passed)\n      .map(([key, val]) => ({ check: key, message: val.message })),\n    fileInfo: data.fileInfo,\n    recommendations: recommendations,\n    completedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "build-fail-response",
      "name": "Build Fail Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "merge-responses",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": "={{ $json.status === 'PASSED' ? 200 : 422 }}",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "qc-response",
      "name": "QC Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"Quality Check {{ $json.status }}\",\n    \"color\": {{ $json.status === 'PASSED' ? 5763719 : 15158332 }},\n    \"fields\": [\n      {\n        \"name\": \"Check ID\",\n        \"value\": \"{{ $json.checkId }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Rating\",\n        \"value\": \"{{ $json.qualityRating }} ({{ $json.qualityScore }}%)\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Threshold\",\n        \"value\": \"{{ $json.threshold }}\",\n        \"inline\": true\n      }\n    ],\n    \"image\": {\n      \"url\": \"{{ $json.assetUrl }}\"\n    },\n    \"footer\": {\n      \"text\": \"Ziggie Quality Pipeline\"\n    },\n    \"timestamp\": \"{{ $json.completedAt }}\"\n  }]\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "discord-qc-notify",
      "name": "Discord QC Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1560, 500]
    }
  ],
  "connections": {
    "Quality Check Webhook": {
      "main": [
        [
          {
            "node": "Validate QC Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate QC Input": {
      "main": [
        [
          {
            "node": "Download Asset",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Asset": {
      "main": [
        [
          {
            "node": "Analyze Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Quality": {
      "main": [
        [
          {
            "node": "Meets Threshold?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meets Threshold?": {
      "main": [
        [
          {
            "node": "Build Pass Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Fail Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Pass Response": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Fail Response": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Responses": {
      "main": [
        [
          {
            "node": "QC Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Discord QC Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "ziggie-quality-check"
  },
  "pinData": {},
  "versionId": "1.0.0",
  "triggerCount": 0,
  "tags": [
    {
      "name": "quality-assurance",
      "id": "tag-qa"
    },
    {
      "name": "asset-validation",
      "id": "tag-validation"
    }
  ]
}
