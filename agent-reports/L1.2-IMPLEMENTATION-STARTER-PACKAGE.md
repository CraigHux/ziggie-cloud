# L1.2 - IMPLEMENTATION STARTER PACKAGE
## Ready-to-Use Code for Hierarchical Agent Deployment

**Package Date:** 2025-11-09
**Version:** 1.0.0
**Approach:** File-Based Protocol (MVP)

---

## SETUP INSTRUCTIONS

### 1. Create Directory Structure

```bash
# Windows Command Prompt
cd C:\Ziggie

mkdir agent-coordinator
mkdir agent-coordinator\coordinator
mkdir agent-coordinator\tests
mkdir agent-queue
mkdir agent-queue\requests
mkdir agent-queue\processing
mkdir agent-queue\responses
mkdir agent-queue\archive
mkdir agent-logs
```

### 2. Install Dependencies

```bash
pip install watchdog psutil pydantic
```

### 3. Create Files

Copy the code sections below into their respective files.

---

## FILE 1: coordinator\__init__.py

```python
"""
Ziggie Agent Coordinator - File-Based Protocol
Enables hierarchical agent deployment (L1 → L2 → L3)
"""

__version__ = "1.0.0"

from .schemas import (
    AgentSpec,
    AgentContext,
    AgentPermissions,
    DeploymentRequest,
    DeploymentResponse
)

from .client import AgentDeploymentClient
from .watcher import FileBasedCoordinator

__all__ = [
    "AgentSpec",
    "AgentContext",
    "AgentPermissions",
    "DeploymentRequest",
    "DeploymentResponse",
    "AgentDeploymentClient",
    "FileBasedCoordinator"
]
```

---

## FILE 2: coordinator\schemas.py

```python
"""
Pydantic schemas for agent deployment protocol
"""

from pydantic import BaseModel, Field
from typing import Literal, Dict, List, Optional
from datetime import datetime
import uuid


class AgentPermissions(BaseModel):
    """File and command permissions for agent"""
    read: List[str] = Field(default_factory=list, description="Readable file paths")
    write: List[str] = Field(default_factory=list, description="Writable file paths")
    execute: List[str] = Field(default_factory=list, description="Executable commands")


class AgentContext(BaseModel):
    """Execution context for agent"""
    working_directory: str = Field(description="Working directory for agent")
    knowledge_base: Optional[str] = Field(None, description="Knowledge base path")
    permissions: AgentPermissions = Field(default_factory=AgentPermissions)


class AgentSpec(BaseModel):
    """Agent deployment specification"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique agent ID")
    level: Literal["L1", "L2", "L3"] = Field(description="Agent hierarchy level")
    name: str = Field(description="Human-readable agent name")
    role: str = Field(description="Agent role description")
    tools: List[str] = Field(default=["Read", "Grep", "Bash"], description="Available tools")
    context: AgentContext = Field(description="Execution context")
    task: str = Field(description="Task description")
    max_iterations: int = Field(default=50, description="Maximum iterations")
    timeout_seconds: int = Field(default=300, description="Timeout in seconds")


class DeploymentRequest(BaseModel):
    """Agent deployment request"""
    version: str = Field(default="1.0", description="Protocol version")
    request_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    parent_agent: str = Field(description="Parent agent name")
    action: Literal["deploy_agent", "status_check", "terminate_agent"]
    agent_spec: Optional[AgentSpec] = None
    target_agent_id: Optional[str] = None


class DeploymentResponse(BaseModel):
    """Agent deployment response"""
    version: str = Field(default="1.0")
    request_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    status: Literal["deployed", "failed", "running", "completed", "terminated"]
    agent_id: str
    pid: Optional[int] = None
    message: str
    output_log: Optional[str] = None
    error: Optional[str] = None
```

---

## FILE 3: coordinator\agent_spawner.py

```python
"""
Agent process spawning and management
"""

import asyncio
import subprocess
import psutil
import json
from pathlib import Path
from datetime import datetime
import logging

from .schemas import AgentSpec

logger = logging.getLogger(__name__)


class AgentSpawner:
    """Spawns and manages agent processes"""

    def __init__(self, log_dir: str = "C:/Ziggie/agent-logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)

    async def spawn_agent(self, agent_spec: AgentSpec) -> dict:
        """
        Spawn a new agent process

        Returns:
            dict: Process information including PID and log file
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_file = self.log_dir / f"{agent_spec.id}_{timestamp}.log"

        # Create agent definition file
        agent_def_path = await self._create_agent_definition(agent_spec)

        # Build command - Using Python + Anthropic SDK
        # (Modify this if Claude CLI is available)
        command = [
            "python", "-c",
            f"print('Agent {agent_spec.name} started'); "
            f"print('Task: {agent_spec.task}'); "
            f"import time; time.sleep(60)"
        ]

        try:
            with open(log_file, 'w') as log_handle:
                process = subprocess.Popen(
                    command,
                    cwd=agent_spec.context.working_directory,
                    stdout=log_handle,
                    stderr=subprocess.STDOUT,
                    creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if hasattr(subprocess, 'CREATE_NEW_PROCESS_GROUP') else 0
                )

            await asyncio.sleep(0.5)

            if not self.is_process_running(process.pid):
                raise RuntimeError("Agent process failed to start")

            logger.info(f"Spawned agent {agent_spec.id} (PID: {process.pid})")

            return {
                'pid': process.pid,
                'log_file': str(log_file),
                'agent_definition': str(agent_def_path),
                'started_at': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"Failed to spawn agent {agent_spec.id}: {e}")
            raise

    async def _create_agent_definition(self, agent_spec: AgentSpec) -> Path:
        """Create agent definition file"""
        agents_dir = Path("C:/Ziggie/.claude/agents")
        agents_dir.mkdir(parents=True, exist_ok=True)

        agent_file = agents_dir / f"{agent_spec.id}.md"

        content = f"""---
name: {agent_spec.name}
role: {agent_spec.role}
level: {agent_spec.level}
tools: {json.dumps(agent_spec.tools)}
max_iterations: {agent_spec.max_iterations}
timeout: {agent_spec.timeout_seconds}
---

# {agent_spec.name}

## Role
{agent_spec.role}

## Task
{agent_spec.task}

## Context
- Working Directory: {agent_spec.context.working_directory}
- Knowledge Base: {agent_spec.context.knowledge_base or "N/A"}

## Permissions
### Read Access
{chr(10).join(f'- {path}' for path in agent_spec.context.permissions.read)}

### Write Access
{chr(10).join(f'- {path}' for path in agent_spec.context.permissions.write)}

### Execute Access
{chr(10).join(f'- {cmd}' for cmd in agent_spec.context.permissions.execute)}
"""

        with open(agent_file, 'w', encoding='utf-8') as f:
            f.write(content)

        logger.info(f"Created agent definition: {agent_file}")
        return agent_file

    def is_process_running(self, pid: int) -> bool:
        """Check if a process is still running"""
        try:
            process = psutil.Process(pid)
            return process.is_running() and process.status() != psutil.STATUS_ZOMBIE
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            return False

    async def terminate_agent(self, pid: int) -> bool:
        """Terminate an agent process"""
        try:
            process = psutil.Process(pid)
            process.terminate()

            try:
                process.wait(timeout=5)
            except psutil.TimeoutExpired:
                process.kill()
                process.wait()

            logger.info(f"Terminated agent process {pid}")
            return True

        except Exception as e:
            logger.error(f"Failed to terminate process {pid}: {e}")
            return False
```

---

## FILE 4: coordinator\watcher.py

```python
"""
File-based coordinator with watchdog monitoring
"""

import asyncio
import json
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent
import logging

from .schemas import DeploymentRequest, DeploymentResponse
from .agent_spawner import AgentSpawner

logger = logging.getLogger(__name__)


class AgentRequestHandler(FileSystemEventHandler):
    """Handles incoming agent deployment requests"""

    def __init__(self, coordinator):
        self.coordinator = coordinator

    def on_created(self, event):
        if isinstance(event, FileCreatedEvent) and event.src_path.endswith('.request.json'):
            asyncio.create_task(self.process_request(event.src_path))

    async def process_request(self, request_path: str):
        """Process a single agent deployment request"""
        try:
            with open(request_path, 'r') as f:
                request_data = json.load(f)

            request = DeploymentRequest(**request_data)
            logger.info(f"Processing request {request.request_id} from {request.parent_agent}")

            processing_path = self._move_to_processing(request_path, request.request_id)

            if request.action == "deploy_agent":
                response = await self.coordinator.deploy_agent(request)
            elif request.action == "status_check":
                response = await self.coordinator.check_status(request.target_agent_id)
            elif request.action == "terminate_agent":
                response = await self.coordinator.terminate_agent(request.target_agent_id)
            else:
                response = DeploymentResponse(
                    request_id=request.request_id,
                    status="failed",
                    agent_id="unknown",
                    message=f"Unknown action: {request.action}",
                    error="Invalid action"
                )

            self._write_response(request.request_id, response)
            self._archive_processing(processing_path)

        except Exception as e:
            logger.error(f"Error processing request {request_path}: {e}")
            self._write_error_response(request_path, str(e))

    def _move_to_processing(self, request_path: str, request_id: str) -> Path:
        processing_dir = Path("C:/Ziggie/agent-queue/processing")
        processing_dir.mkdir(parents=True, exist_ok=True)
        processing_path = processing_dir / f"{request_id}.processing.json"
        Path(request_path).rename(processing_path)
        return processing_path

    def _write_response(self, request_id: str, response: DeploymentResponse):
        responses_dir = Path("C:/Ziggie/agent-queue/responses")
        responses_dir.mkdir(parents=True, exist_ok=True)
        response_path = responses_dir / f"{request_id}.response.json"
        with open(response_path, 'w') as f:
            json.dump(response.model_dump(mode='json'), f, indent=2, default=str)

    def _archive_processing(self, processing_path: Path):
        from datetime import datetime
        archive_dir = Path("C:/Ziggie/agent-queue/archive") / datetime.now().strftime("%Y-%m-%d")
        archive_dir.mkdir(parents=True, exist_ok=True)
        processing_path.rename(archive_dir / processing_path.name)

    def _write_error_response(self, request_path: str, error: str):
        responses_dir = Path("C:/Ziggie/agent-queue/responses")
        responses_dir.mkdir(parents=True, exist_ok=True)
        filename = Path(request_path).stem
        response_path = responses_dir / f"{filename}.error.json"
        with open(response_path, 'w') as f:
            json.dump({
                "version": "1.0",
                "status": "failed",
                "error": error,
                "original_file": request_path
            }, f, indent=2)


class FileBasedCoordinator:
    """File-based agent deployment coordinator"""

    def __init__(self, queue_dir: str = "C:/Ziggie/agent-queue"):
        self.queue_dir = Path(queue_dir)
        self.requests_dir = self.queue_dir / "requests"
        self.spawner = AgentSpawner()
        self.observer = None
        self.active_agents = {}

        self.requests_dir.mkdir(parents=True, exist_ok=True)
        (self.queue_dir / "processing").mkdir(exist_ok=True)
        (self.queue_dir / "responses").mkdir(exist_ok=True)
        (self.queue_dir / "archive").mkdir(exist_ok=True)

    async def start(self):
        """Start the file watcher"""
        logger.info("Starting File-Based Agent Coordinator")

        event_handler = AgentRequestHandler(self)
        self.observer = Observer()
        self.observer.schedule(event_handler, str(self.requests_dir), recursive=False)
        self.observer.start()

        logger.info(f"Watching {self.requests_dir} for agent deployment requests")

        try:
            while True:
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            self.observer.stop()

        self.observer.join()

    async def deploy_agent(self, request: DeploymentRequest) -> DeploymentResponse:
        """Deploy a new agent"""
        try:
            agent_spec = request.agent_spec
            process_info = await self.spawner.spawn_agent(agent_spec)
            self.active_agents[agent_spec.id] = process_info

            return DeploymentResponse(
                request_id=request.request_id,
                status="deployed",
                agent_id=agent_spec.id,
                pid=process_info['pid'],
                message=f"Agent {agent_spec.name} deployed successfully",
                output_log=process_info['log_file']
            )

        except Exception as e:
            logger.error(f"Failed to deploy agent: {e}")
            return DeploymentResponse(
                request_id=request.request_id,
                status="failed",
                agent_id=agent_spec.id if agent_spec else "unknown",
                message="Deployment failed",
                error=str(e)
            )

    async def check_status(self, agent_id: str) -> DeploymentResponse:
        """Check status of a running agent"""
        if agent_id not in self.active_agents:
            return DeploymentResponse(
                request_id="status-check",
                status="failed",
                agent_id=agent_id,
                message="Agent not found",
                error=f"No active agent with ID {agent_id}"
            )

        process_info = self.active_agents[agent_id]
        is_running = self.spawner.is_process_running(process_info['pid'])

        return DeploymentResponse(
            request_id="status-check",
            status="running" if is_running else "completed",
            agent_id=agent_id,
            pid=process_info['pid'],
            message=f"Agent is {'running' if is_running else 'completed'}",
            output_log=process_info['log_file']
        )

    async def terminate_agent(self, agent_id: str) -> DeploymentResponse:
        """Terminate a running agent"""
        if agent_id not in self.active_agents:
            return DeploymentResponse(
                request_id="terminate",
                status="failed",
                agent_id=agent_id,
                message="Agent not found",
                error=f"No active agent with ID {agent_id}"
            )

        process_info = self.active_agents[agent_id]
        success = await self.spawner.terminate_agent(process_info['pid'])

        if success:
            del self.active_agents[agent_id]
            return DeploymentResponse(
                request_id="terminate",
                status="terminated",
                agent_id=agent_id,
                message="Agent terminated successfully"
            )
        else:
            return DeploymentResponse(
                request_id="terminate",
                status="failed",
                agent_id=agent_id,
                message="Failed to terminate agent",
                error="Process termination failed"
            )
```

---

## FILE 5: coordinator\client.py

```python
"""
Client for submitting agent deployment requests (used by Ziggie)
"""

import json
import asyncio
from pathlib import Path
from typing import Optional
from datetime import datetime

from .schemas import DeploymentRequest, DeploymentResponse, AgentSpec


class AgentDeploymentClient:
    """Client for submitting agent deployment requests"""

    def __init__(self, queue_dir: str = "C:/Ziggie/agent-queue"):
        self.queue_dir = Path(queue_dir)
        self.requests_dir = self.queue_dir / "requests"
        self.responses_dir = self.queue_dir / "responses"

        self.requests_dir.mkdir(parents=True, exist_ok=True)
        self.responses_dir.mkdir(parents=True, exist_ok=True)

    async def deploy_agent(
        self,
        agent_spec: AgentSpec,
        parent_agent: str = "Ziggie",
        wait_for_response: bool = True,
        timeout: int = 30
    ) -> DeploymentResponse:
        """Deploy a sub-agent"""
        request = DeploymentRequest(
            parent_agent=parent_agent,
            action="deploy_agent",
            agent_spec=agent_spec
        )

        request_file = self.requests_dir / f"{request.request_id}.request.json"
        with open(request_file, 'w') as f:
            json.dump(request.model_dump(mode='json'), f, indent=2, default=str)

        if not wait_for_response:
            return DeploymentResponse(
                request_id=request.request_id,
                status="submitted",
                agent_id=agent_spec.id,
                message="Request submitted to coordinator"
            )

        return await self._wait_for_response(request.request_id, timeout)

    async def check_agent_status(self, agent_id: str, timeout: int = 10) -> DeploymentResponse:
        """Check status of a deployed agent"""
        request = DeploymentRequest(
            parent_agent="Ziggie",
            action="status_check",
            target_agent_id=agent_id
        )

        request_file = self.requests_dir / f"{request.request_id}.request.json"
        with open(request_file, 'w') as f:
            json.dump(request.model_dump(mode='json'), f, indent=2, default=str)

        return await self._wait_for_response(request.request_id, timeout)

    async def terminate_agent(self, agent_id: str, timeout: int = 10) -> DeploymentResponse:
        """Terminate a running agent"""
        request = DeploymentRequest(
            parent_agent="Ziggie",
            action="terminate_agent",
            target_agent_id=agent_id
        )

        request_file = self.requests_dir / f"{request.request_id}.request.json"
        with open(request_file, 'w') as f:
            json.dump(request.model_dump(mode='json'), f, indent=2, default=str)

        return await self._wait_for_response(request.request_id, timeout)

    async def _wait_for_response(self, request_id: str, timeout: int) -> DeploymentResponse:
        """Wait for coordinator to process request"""
        response_file = self.responses_dir / f"{request_id}.response.json"
        error_file = self.responses_dir / f"{request_id}.error.json"

        start_time = asyncio.get_event_loop().time()

        while (asyncio.get_event_loop().time() - start_time) < timeout:
            if response_file.exists():
                with open(response_file, 'r') as f:
                    response_data = json.load(f)
                return DeploymentResponse(**response_data)

            if error_file.exists():
                with open(error_file, 'r') as f:
                    error_data = json.load(f)
                return DeploymentResponse(
                    request_id=request_id,
                    status="failed",
                    agent_id="unknown",
                    message="Request processing failed",
                    error=error_data.get('error', 'Unknown error')
                )

            await asyncio.sleep(0.1)

        return DeploymentResponse(
            request_id=request_id,
            status="failed",
            agent_id="unknown",
            message="Request timeout",
            error=f"No response received within {timeout} seconds"
        )
```

---

## FILE 6: coordinator\main.py

```python
"""
Main entry point for Agent Coordinator
"""

import asyncio
import logging

from .watcher import FileBasedCoordinator

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)


async def main():
    """Start the coordinator"""
    coordinator = FileBasedCoordinator()
    await coordinator.start()


if __name__ == "__main__":
    asyncio.run(main())
```

---

## FILE 7: tests\test_basic.py

```python
"""
Basic integration test for agent deployment
"""

import asyncio
import sys
from pathlib import Path

# Add coordinator to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from coordinator import (
    AgentDeploymentClient,
    AgentSpec,
    AgentContext,
    AgentPermissions
)


async def test_deploy_agent():
    """Test deploying a simple agent"""
    print("Starting agent deployment test...")

    client = AgentDeploymentClient()

    # Define test agent
    test_agent = AgentSpec(
        id="test-agent-001",
        level="L1",
        name="Test Agent",
        role="Testing agent deployment system",
        tools=["Read", "Grep"],
        context=AgentContext(
            working_directory="C:/Ziggie",
            permissions=AgentPermissions(
                read=["C:/Ziggie/**"],
                write=["C:/Ziggie/agent-reports/**"]
            )
        ),
        task="Perform test operations and report status",
        max_iterations=10,
        timeout_seconds=60
    )

    print(f"Deploying agent: {test_agent.name}")

    # Deploy agent
    response = await client.deploy_agent(test_agent, wait_for_response=True)

    print(f"Response status: {response.status}")
    print(f"Message: {response.message}")

    if response.status == "deployed":
        print(f"Agent deployed successfully!")
        print(f"PID: {response.pid}")
        print(f"Log file: {response.output_log}")

        # Wait a moment
        await asyncio.sleep(2)

        # Check status
        print("\nChecking agent status...")
        status_response = await client.check_agent_status("test-agent-001")
        print(f"Agent status: {status_response.status}")

        # Terminate
        print("\nTerminating agent...")
        term_response = await client.terminate_agent("test-agent-001")
        print(f"Termination: {term_response.status}")

    else:
        print(f"Deployment failed: {response.error}")


if __name__ == "__main__":
    asyncio.run(test_deploy_agent())
```

---

## FILE 8: requirements.txt

```
watchdog>=6.0.0
psutil>=7.1.0
pydantic>=2.12.0
pydantic-settings>=2.11.0
```

---

## USAGE GUIDE

### Step 1: Start the Coordinator

```bash
cd C:\Ziggie\agent-coordinator
python -m coordinator.main
```

You should see:
```
2025-11-09 15:30:00 - coordinator.watcher - INFO - Starting File-Based Agent Coordinator
2025-11-09 15:30:00 - coordinator.watcher - INFO - Watching C:\Ziggie\agent-queue\requests for agent deployment requests
```

### Step 2: Run the Test (in another terminal)

```bash
cd C:\Ziggie\agent-coordinator
python tests\test_basic.py
```

Expected output:
```
Starting agent deployment test...
Deploying agent: Test Agent
Response status: deployed
Message: Agent Test Agent deployed successfully
Agent deployed successfully!
PID: 12345
Log file: C:\Ziggie\agent-logs\test-agent-001_20251109_153000.log

Checking agent status...
Agent status: running

Terminating agent...
Termination: terminated
```

---

## INTEGRATION WITH ZIGGIE

From Ziggie's perspective, use the client library:

```python
# In Ziggie's code
from coordinator import (
    AgentDeploymentClient,
    AgentSpec,
    AgentContext,
    AgentPermissions
)

async def deploy_overwatch():
    """Deploy Overwatch sub-agent from Ziggie"""
    client = AgentDeploymentClient()

    overwatch = AgentSpec(
        id="overwatch-001",
        level="L1",
        name="Overwatch",
        role="Project oversight and L2 agent coordination",
        tools=["Read", "Grep", "Bash", "TodoWrite"],
        context=AgentContext(
            working_directory="C:/Ziggie/ai-agents",
            knowledge_base="C:/Ziggie/ai-agents/knowledge-base",
            permissions=AgentPermissions(
                read=["C:/Ziggie/**"],
                write=["C:/Ziggie/agent-reports/**"],
                execute=["git", "docker", "python"]
            )
        ),
        task="Monitor and coordinate L2 agent activities",
        max_iterations=100,
        timeout_seconds=600
    )

    response = await client.deploy_agent(overwatch)

    if response.status == "deployed":
        print(f"✅ Overwatch deployed (PID: {response.pid})")
        return response.agent_id
    else:
        print(f"❌ Deployment failed: {response.error}")
        return None
```

---

## TROUBLESHOOTING

### Coordinator not detecting requests
- Check that coordinator is running
- Verify requests directory: `C:\Ziggie\agent-queue\requests`
- Check file permissions

### Agent fails to spawn
- Check working directory exists
- Verify Python is in PATH
- Check log file for errors

### Response timeout
- Increase timeout parameter
- Check coordinator logs
- Verify watchdog is functioning

---

## NEXT STEPS

1. **Test with simple agent** - Use test_basic.py
2. **Deploy Overwatch** - First real sub-agent
3. **Monitor logs** - Check agent-logs directory
4. **Add REST API** - Week 2 enhancement
5. **Enable nesting** - L1 → L2 → L3

---

**Package Status:** READY TO IMPLEMENT
**Estimated Setup Time:** 30 minutes
**Estimated Test Time:** 15 minutes
**Total Time to Working MVP:** 45 minutes

**Support:** See full technical analysis in L1.2-TECHNICAL-FEASIBILITY-ANALYSIS.md
